{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SocioPatterns utilities Documentation for usefull utilities used to investigate temporal Networks","title":"Home"},{"location":"#sociopatterns-utilities","text":"Documentation for usefull utilities used to investigate temporal Networks","title":"SocioPatterns utilities"},{"location":"construction/","text":"Construction import the library using import construction load_data construction.load_data(path) Input Path = String specifing the input file. Output Data = np.ndarray of elements, each line is an entry af the array. individuals construction.individuals(data) Input Data = The loaded input file. Output An unique list of people in the input data. split_input_data construction.split_input_data(data, gap=19) Input Data = The loaded input file. gap = gap of time used to separate the data. Output An multidimensional array, where each array represent the interacion among entries in the specified gap of time. build_graphs construction.build_graphs(data,gap=19) Input data = The loaded input file. gap = gap of time used to separate the data. Output Graphs = An array, where each entry is a nx.Graph() that represent the interacion among entries in the specified gap of time. pos = The networkx position of each node in the graph layout, it is used if you want to use also the funciont plot_graphs . build_weighted_graph construction.build\\_weighted\\_graph(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes within the gap of time. build_weighted_graph_2 construction.build\\_weighted\\_graph\\_2(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes, consecutive interconnections does not twice.","title":"Construction"},{"location":"construction/#construction","text":"import the library using import construction","title":"Construction"},{"location":"construction/#load_data","text":"construction.load_data(path) Input Path = String specifing the input file. Output Data = np.ndarray of elements, each line is an entry af the array.","title":"load_data"},{"location":"construction/#individuals","text":"construction.individuals(data) Input Data = The loaded input file. Output An unique list of people in the input data.","title":"individuals"},{"location":"construction/#split_input_data","text":"construction.split_input_data(data, gap=19) Input Data = The loaded input file. gap = gap of time used to separate the data. Output An multidimensional array, where each array represent the interacion among entries in the specified gap of time.","title":"split_input_data"},{"location":"construction/#build_graphs","text":"construction.build_graphs(data,gap=19) Input data = The loaded input file. gap = gap of time used to separate the data. Output Graphs = An array, where each entry is a nx.Graph() that represent the interacion among entries in the specified gap of time. pos = The networkx position of each node in the graph layout, it is used if you want to use also the funciont plot_graphs .","title":"build_graphs"},{"location":"construction/#build_weighted_graph","text":"construction.build\\_weighted\\_graph(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes within the gap of time.","title":"build_weighted_graph"},{"location":"construction/#build_weighted_graph_2","text":"construction.build\\_weighted\\_graph\\_2(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes, consecutive interconnections does not twice.","title":"build_weighted_graph_2"},{"location":"dataset/","text":"Data sets The data sets can be downloaded from sociopatterns.org co-presence A single folder that contains six different social contexts, each file has its metadata file. InVS13 Workplace 2013 Format Format: time, node i, node j Metadata Format: ID : Department 5 Departments: DISQ DSE SFLE DMCT SRH InVS15 Workplace 2015 Format Format: time, node i, node j Metadata Format: ID : Department 12 Departments: DCAR DG DISQ DMCT DMI DSE DST SCOM SDOC SFLE SRH SSI LH10 Hospital Format Format: time, node i, node j Metadata Format: ID : Job 5 Jobs: Admin Paramed Med Patient Etude LyonSchool Primary school Format Format: time, node i, node j Metadata Format: ID : Class or Teacher 10 groups: cpa cpb ce1a ce1b ce2a cm1a cm1b cm2a cm2b teachers SFHH Conference Format Format: time, node i, node j Metadata There is no metadata. Thiers13 These data sets correspond to the contacts and friendship relations between students in a high school in Marseilles, France, in December 2013. Format Format: time, node i, node j Metadata Format: ID : Class or Teacher 9 groups: 2BIO1 2BIO2 2BIO3 MP MPst1 MPst2 PC PCst PSIst","title":"Data sets"},{"location":"dataset/#data-sets","text":"The data sets can be downloaded from sociopatterns.org","title":"Data sets"},{"location":"dataset/#co-presence","text":"A single folder that contains six different social contexts, each file has its metadata file.","title":"co-presence"},{"location":"dataset/#invs13","text":"Workplace 2013 Format Format: time, node i, node j Metadata Format: ID : Department 5 Departments: DISQ DSE SFLE DMCT SRH","title":"InVS13"},{"location":"dataset/#invs15","text":"Workplace 2015 Format Format: time, node i, node j Metadata Format: ID : Department 12 Departments: DCAR DG DISQ DMCT DMI DSE DST SCOM SDOC SFLE SRH SSI","title":"InVS15"},{"location":"dataset/#lh10","text":"Hospital Format Format: time, node i, node j Metadata Format: ID : Job 5 Jobs: Admin Paramed Med Patient Etude","title":"LH10"},{"location":"dataset/#lyonschool","text":"Primary school Format Format: time, node i, node j Metadata Format: ID : Class or Teacher 10 groups: cpa cpb ce1a ce1b ce2a cm1a cm1b cm2a cm2b teachers","title":"LyonSchool"},{"location":"dataset/#sfhh","text":"Conference Format Format: time, node i, node j Metadata There is no metadata.","title":"SFHH"},{"location":"dataset/#thiers13","text":"These data sets correspond to the contacts and friendship relations between students in a high school in Marseilles, France, in December 2013. Format Format: time, node i, node j Metadata Format: ID : Class or Teacher 9 groups: 2BIO1 2BIO2 2BIO3 MP MPst1 MPst2 PC PCst PSIst","title":"Thiers13"},{"location":"utilities/","text":"Utilities import the library using import utilities get_weights utilities.get_weights(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array of weights. Output weights = np.ndarray or dictionary of weights. get_neigh_weights utilities.get_neigh_weights(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output weights = np.ndarray or dictionary of weights, where each weigth is the sum of the weights of the neighbours of the node. clustering_coeff utilities.clustering_coeff(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. betweenness_centrality utilities.betweenness_centrality(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. closeness_centrality utilities.closeness_centrality(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. degree_centrality utilities.degree_centrality(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. spectral_gap utilities.spectral_gap(Graph, binary_adj_matrix=False) Input Graph = A networkx graph. binary_adj_matrix = If it is true then returns the spectral gap using an unweighted adj matrix, while if it is false then returns the spectral gap computed using an adj matrix where the element in position i, j is equal to the weights on edge from node i to node j. Output spectral_gap = It returns a float representing the gap between the first and the second smallest eigenvalue. find_a_c_cut utilities.find_a_c_cut(data,min_bin=40,max_bin=150,interval=1): Input data = The loaded input file. min_bin = smallest number of bins max_bin = largest number of bins intervals = np.arange(min_bin,max_bin,intervals) Output a = exponent of the fitted power low. c = constant of the fitted power low. cut = position\\ of where the power low is fitted.","title":"Utilities"},{"location":"utilities/#utilities","text":"import the library using import utilities","title":"Utilities"},{"location":"utilities/#get_weights","text":"utilities.get_weights(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array of weights. Output weights = np.ndarray or dictionary of weights.","title":"get_weights"},{"location":"utilities/#get_neigh_weights","text":"utilities.get_neigh_weights(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output weights = np.ndarray or dictionary of weights, where each weigth is the sum of the weights of the neighbours of the node.","title":"get_neigh_weights"},{"location":"utilities/#clustering_coeff","text":"utilities.clustering_coeff(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"clustering_coeff"},{"location":"utilities/#betweenness_centrality","text":"utilities.betweenness_centrality(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"betweenness_centrality"},{"location":"utilities/#closeness_centrality","text":"utilities.closeness_centrality(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"closeness_centrality"},{"location":"utilities/#degree_centrality","text":"utilities.degree_centrality(Graph, dictionary = False) Input Graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"degree_centrality"},{"location":"utilities/#spectral_gap","text":"utilities.spectral_gap(Graph, binary_adj_matrix=False) Input Graph = A networkx graph. binary_adj_matrix = If it is true then returns the spectral gap using an unweighted adj matrix, while if it is false then returns the spectral gap computed using an adj matrix where the element in position i, j is equal to the weights on edge from node i to node j. Output spectral_gap = It returns a float representing the gap between the first and the second smallest eigenvalue.","title":"spectral_gap"},{"location":"utilities/#find_a_c_cut","text":"utilities.find_a_c_cut(data,min_bin=40,max_bin=150,interval=1): Input data = The loaded input file. min_bin = smallest number of bins max_bin = largest number of bins intervals = np.arange(min_bin,max_bin,intervals) Output a = exponent of the fitted power low. c = constant of the fitted power low. cut = position\\ of where the power low is fitted.","title":"find_a_c_cut"}]}