{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SocioPatterns utilities Documentation for usefull utilities used to investigate temporal Networks","title":"Home"},{"location":"#sociopatterns-utilities","text":"Documentation for usefull utilities used to investigate temporal Networks","title":"SocioPatterns utilities"},{"location":"construction/","text":"Construction import the library using import construction load_data construction.load_data(path) Input Path = String specifing the input file. Output Data = np.ndarray of elements, each line is an entry af the array. individuals construction.individuals(data) Input Data = The loaded input file. Output An unique list of people in the input data. split_input_data construction.split_input_data(data, gap=19) Input Data = The loaded input file. gap = gap of time used to separate the data. Output An multidimensional array, where each array represent the interacion among entries in the specified gap of time. build_graphs construction.build_graphs(data,gap=19) Input data = The loaded input file. gap = gap of time used to separate the data. Output Graphs = An array, where each entry is a nx.Graph() that represent the interacion among entries in the specified gap of time. pos = The networkx position of each node in the graph layout, it is used if you want to use also the funciont plot_graphs . build_weighted_graph construction.build\\_weighted\\_graph(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes within the gap of time. build_weighted_graph_2 construction.build\\_weighted\\_graph\\_2(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes, consecutive interconnections does not twice.","title":"Construction"},{"location":"construction/#construction","text":"import the library using import construction","title":"Construction"},{"location":"construction/#load_data","text":"construction.load_data(path) Input Path = String specifing the input file. Output Data = np.ndarray of elements, each line is an entry af the array.","title":"load_data"},{"location":"construction/#individuals","text":"construction.individuals(data) Input Data = The loaded input file. Output An unique list of people in the input data.","title":"individuals"},{"location":"construction/#split_input_data","text":"construction.split_input_data(data, gap=19) Input Data = The loaded input file. gap = gap of time used to separate the data. Output An multidimensional array, where each array represent the interacion among entries in the specified gap of time.","title":"split_input_data"},{"location":"construction/#build_graphs","text":"construction.build_graphs(data,gap=19) Input data = The loaded input file. gap = gap of time used to separate the data. Output Graphs = An array, where each entry is a nx.Graph() that represent the interacion among entries in the specified gap of time. pos = The networkx position of each node in the graph layout, it is used if you want to use also the funciont plot_graphs .","title":"build_graphs"},{"location":"construction/#build_weighted_graph","text":"construction.build\\_weighted\\_graph(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes within the gap of time.","title":"build_weighted_graph"},{"location":"construction/#build_weighted_graph_2","text":"construction.build\\_weighted\\_graph\\_2(data,gap) Input Data = The loaded input file. gap = gap of time used to separate the data. Output Return a Graph of interaction of people. Each edge has a weight equal to the count of interaction between the nodes, consecutive interconnections does not twice.","title":"build_weighted_graph_2"},{"location":"utilities/","text":"Utilities import the library using import utilities get_weights utilities.get\\_weights(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array of weights. Output weights = np.ndarray or dictionary of weights. get_neigh_weights utilities.get\\_neigh\\_weights(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output weights = np.ndarray or dictionary of weights, where each weigth is the sum of the weights of the neighbours of the node. clustering_coeff utilities.clustering\\_coeff(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. betweenness_centrality utilities.betweenness\\_centrality(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. closeness_centrality utilities.closeness\\_centrality(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. degree_centrality utilities.degree\\_centrality(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"Utilities"},{"location":"utilities/#utilities","text":"import the library using import utilities","title":"Utilities"},{"location":"utilities/#get_weights","text":"utilities.get\\_weights(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array of weights. Output weights = np.ndarray or dictionary of weights.","title":"get_weights"},{"location":"utilities/#get_neigh_weights","text":"utilities.get\\_neigh\\_weights(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output weights = np.ndarray or dictionary of weights, where each weigth is the sum of the weights of the neighbours of the node.","title":"get_neigh_weights"},{"location":"utilities/#clustering_coeff","text":"utilities.clustering\\_coeff(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"clustering_coeff"},{"location":"utilities/#betweenness_centrality","text":"utilities.betweenness\\_centrality(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"betweenness_centrality"},{"location":"utilities/#closeness_centrality","text":"utilities.closeness\\_centrality(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"closeness_centrality"},{"location":"utilities/#degree_centrality","text":"utilities.degree\\_centrality(Graph, dictionary = False) Input Graph = A networkx garaph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients.","title":"degree_centrality"}]}