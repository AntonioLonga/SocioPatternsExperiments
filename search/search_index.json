{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"construction/","text":"Construction Import the library using import construction split_data_in_groups construction.split_data_in_groups(path_data,path_metadata) Input path_data = path of the input data. path_metadata = path of the input metadata Output gropus = a dictionary [group : data], where group is the name taken from the metadata, while data are the data related to a sepcific group. load_data construction.load_data(path) Input path = path of the input data. Output data = np.ndarray of the loaded data. Each row t,i,j represent the interaction among node i and node j at time t. individuals construction.individuals(path) Input data = The loaded file. Output individuals = np.ndarray of individuals in the dataset. build_weighted_graph construction.build_weighted_graph(data,gap=19) Input data = The loaded file. gap = A gap of time. Output Graph = It returns a weighted nx.Graph, where the weight on a edge i-j represent the number of interactions among node i and node j. build_weighted_graph_2 construction.build_weighted_graph_2(data,gap=19) Input data = The loaded file. gap = A gap of time. Output Graph = It returns a weighted nx.Graph, where the weight on a edge i-j represent the number of interactions among node i and node j. With this construction, consecutive interaction are counted as a single interaction. build_graphs construction.build_graphs(data,gap=19) Input data = The loaded file. gap = A gap of time. Output array of Graphs = It returns an array of graphs, each graph represent the interaction of nodes, within time t and time t+gap. split_input_data construction.split_input_data(data, gap=19) Input data = The loaded file. gap = A gap of time. Output np.array = an array of data, each element represent the interaction within the gap of time.","title":"Construction"},{"location":"construction/#construction","text":"Import the library using import construction","title":"Construction"},{"location":"construction/#split_data_in_groups","text":"construction.split_data_in_groups(path_data,path_metadata)","title":"split_data_in_groups"},{"location":"construction/#input","text":"path_data = path of the input data. path_metadata = path of the input metadata","title":"Input"},{"location":"construction/#output","text":"gropus = a dictionary [group : data], where group is the name taken from the metadata, while data are the data related to a sepcific group.","title":"Output"},{"location":"construction/#load_data","text":"construction.load_data(path)","title":"load_data"},{"location":"construction/#input_1","text":"path = path of the input data.","title":"Input"},{"location":"construction/#output_1","text":"data = np.ndarray of the loaded data. Each row t,i,j represent the interaction among node i and node j at time t.","title":"Output"},{"location":"construction/#individuals","text":"construction.individuals(path)","title":"individuals"},{"location":"construction/#input_2","text":"data = The loaded file.","title":"Input"},{"location":"construction/#output_2","text":"individuals = np.ndarray of individuals in the dataset.","title":"Output"},{"location":"construction/#build_weighted_graph","text":"construction.build_weighted_graph(data,gap=19)","title":"build_weighted_graph"},{"location":"construction/#input_3","text":"data = The loaded file. gap = A gap of time.","title":"Input"},{"location":"construction/#output_3","text":"Graph = It returns a weighted nx.Graph, where the weight on a edge i-j represent the number of interactions among node i and node j.","title":"Output"},{"location":"construction/#build_weighted_graph_2","text":"construction.build_weighted_graph_2(data,gap=19)","title":"build_weighted_graph_2"},{"location":"construction/#input_4","text":"data = The loaded file. gap = A gap of time.","title":"Input"},{"location":"construction/#output_4","text":"Graph = It returns a weighted nx.Graph, where the weight on a edge i-j represent the number of interactions among node i and node j. With this construction, consecutive interaction are counted as a single interaction.","title":"Output"},{"location":"construction/#build_graphs","text":"construction.build_graphs(data,gap=19)","title":"build_graphs"},{"location":"construction/#input_5","text":"data = The loaded file. gap = A gap of time.","title":"Input"},{"location":"construction/#output_5","text":"array of Graphs = It returns an array of graphs, each graph represent the interaction of nodes, within time t and time t+gap.","title":"Output"},{"location":"construction/#split_input_data","text":"construction.split_input_data(data, gap=19)","title":"split_input_data"},{"location":"construction/#input_6","text":"data = The loaded file. gap = A gap of time.","title":"Input"},{"location":"construction/#output_6","text":"np.array = an array of data, each element represent the interaction within the gap of time.","title":"Output"},{"location":"utilities/","text":"Utility Import the library using import utilities get_weights utilities.get_weights(graph, dictionary = False) Input graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array of weights. Output weights = np.ndarray or dictionary of weights. get_neigh_weights utilities.get_neigh_weights(Graph, dictionary = False) Input graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output weights = np.ndarray or dictionary of weights, where each weigth is the sum of the weights of the neighbours of the node. clustering_coeff utilities.clustering_coeff(Graph, dictionary = False) Input graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of coefficients. betweenness_centrality utilities.betweenness_centrality(Graph, dictionary = False) Input graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of values. betweenness_centrality utilities.betweenness_centrality(Graph, dictionary = False) Input graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array. Output coeff = np.ndarray or dictionary of values. spectral_gap utilities.spectral_gap(Graph, binary_adj_matrix=False) Input graph = A networkx graph. binary_adj_matrix = If it is true then returns the spectral gap using an unweighted adj matrix, while if it is false then returns the spectral gap computed using an adj matrix where the element in position i, j is equal to the weights on edge from node i to node j. Output spectral_gap = It returns a float representing the gap between the first and the second smallest eigenvalue. find_a_c_cut utilities.find_a_c_cut(data,min_bin=40,max_bin=150,interval=1) Input data = a file where you want to fit a power low. min_bin = smallest number of bins max_bin = largest number of bins intervals = np.arange(min_bin,max_bin,intervals) Output a = exponent of the fitted power low. c = constant of the fitted power low. cut = position\\ of where the power low is fitted.","title":"Utility"},{"location":"utilities/#utility","text":"Import the library using import utilities","title":"Utility"},{"location":"utilities/#get_weights","text":"utilities.get_weights(graph, dictionary = False)","title":"get_weights"},{"location":"utilities/#input","text":"graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array of weights.","title":"Input"},{"location":"utilities/#output","text":"weights = np.ndarray or dictionary of weights.","title":"Output"},{"location":"utilities/#get_neigh_weights","text":"utilities.get_neigh_weights(Graph, dictionary = False)","title":"get_neigh_weights"},{"location":"utilities/#input_1","text":"graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array.","title":"Input"},{"location":"utilities/#output_1","text":"weights = np.ndarray or dictionary of weights, where each weigth is the sum of the weights of the neighbours of the node.","title":"Output"},{"location":"utilities/#clustering_coeff","text":"utilities.clustering_coeff(Graph, dictionary = False)","title":"clustering_coeff"},{"location":"utilities/#input_2","text":"graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array.","title":"Input"},{"location":"utilities/#output_2","text":"coeff = np.ndarray or dictionary of coefficients.","title":"Output"},{"location":"utilities/#betweenness_centrality","text":"utilities.betweenness_centrality(Graph, dictionary = False)","title":"betweenness_centrality"},{"location":"utilities/#input_3","text":"graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array.","title":"Input"},{"location":"utilities/#output_3","text":"coeff = np.ndarray or dictionary of values.","title":"Output"},{"location":"utilities/#betweenness_centrality_1","text":"utilities.betweenness_centrality(Graph, dictionary = False)","title":"betweenness_centrality"},{"location":"utilities/#input_4","text":"graph = A networkx graph. dictionary = If it is true then returns a dictionary [node_id : weights]. If it is false then returns an np.array.","title":"Input"},{"location":"utilities/#output_4","text":"coeff = np.ndarray or dictionary of values.","title":"Output"},{"location":"utilities/#spectral_gap","text":"utilities.spectral_gap(Graph, binary_adj_matrix=False)","title":"spectral_gap"},{"location":"utilities/#input_5","text":"graph = A networkx graph. binary_adj_matrix = If it is true then returns the spectral gap using an unweighted adj matrix, while if it is false then returns the spectral gap computed using an adj matrix where the element in position i, j is equal to the weights on edge from node i to node j.","title":"Input"},{"location":"utilities/#output_5","text":"spectral_gap = It returns a float representing the gap between the first and the second smallest eigenvalue.","title":"Output"},{"location":"utilities/#find_a_c_cut","text":"utilities.find_a_c_cut(data,min_bin=40,max_bin=150,interval=1)","title":"find_a_c_cut"},{"location":"utilities/#input_6","text":"data = a file where you want to fit a power low. min_bin = smallest number of bins max_bin = largest number of bins intervals = np.arange(min_bin,max_bin,intervals)","title":"Input"},{"location":"utilities/#output_6","text":"a = exponent of the fitted power low. c = constant of the fitted power low. cut = position\\ of where the power low is fitted.","title":"Output"}]}